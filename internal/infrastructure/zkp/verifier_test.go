package zkp_test

import (
	"os"
	"path/filepath"
	"runtime"
	"testing"

	"github.com/liverty-music/backend/internal/infrastructure/zkp"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

// testdataDir returns the absolute path to configs/zkp/testdata.
func testdataDir() string {
	_, filename, _, _ := runtime.Caller(0)
	return filepath.Join(filepath.Dir(filename), "..", "..", "..", "configs", "zkp", "testdata")
}

// vkPath returns the absolute path to the verification key.
func vkPath() string {
	_, filename, _, _ := runtime.Caller(0)
	return filepath.Join(filepath.Dir(filename), "..", "..", "..", "configs", "zkp", "verification_key.json")
}

func TestVerifier_RoundTrip(t *testing.T) {
	t.Parallel()

	// Load verification key.
	verifier, err := zkp.NewVerifier(vkPath())
	require.NoError(t, err, "failed to load verification key")

	// Load proof and public signals generated by snarkjs.
	proofJSON, err := os.ReadFile(filepath.Join(testdataDir(), "proof.json"))
	require.NoError(t, err, "failed to read proof.json")

	publicSignalsJSON, err := os.ReadFile(filepath.Join(testdataDir(), "public_signals.json"))
	require.NoError(t, err, "failed to read public_signals.json")

	// Verify the proof through circom2gnark -> gnark Groth16.
	verified, err := verifier.Verify(string(proofJSON), string(publicSignalsJSON))
	require.NoError(t, err, "verification returned error")
	assert.True(t, verified, "valid proof should verify successfully")
}

func TestVerifier_InvalidProof(t *testing.T) {
	t.Parallel()

	verifier, err := zkp.NewVerifier(vkPath())
	require.NoError(t, err)

	// Use the real public signals but a tampered proof (flip a digit).
	publicSignalsJSON, err := os.ReadFile(filepath.Join(testdataDir(), "public_signals.json"))
	require.NoError(t, err)

	tamperedProof := `{
		"pi_a": ["1", "2", "1"],
		"pi_b": [["3", "4"], ["5", "6"], ["1", "0"]],
		"pi_c": ["7", "8", "1"],
		"protocol": "groth16",
		"curve": "bn128"
	}`

	verified, err := verifier.Verify(tamperedProof, string(publicSignalsJSON))
	// Bogus proof points fail at the BN254 curve subgroup check during conversion.
	assert.Error(t, err, "tampered proof should fail conversion")
	assert.False(t, verified, "tampered proof should not verify")
}

func TestVerifier_TamperedPublicSignals(t *testing.T) {
	t.Parallel()

	verifier, err := zkp.NewVerifier(vkPath())
	require.NoError(t, err)

	proofJSON, err := os.ReadFile(filepath.Join(testdataDir(), "proof.json"))
	require.NoError(t, err)

	// Tamper public signals: change the merkle root.
	tamperedSignals := `["999", "113059749145936325402354257176981405696", "1979364390381290741254965743233963379247311716839167577312065342320917663046"]`

	verified, err := verifier.Verify(string(proofJSON), tamperedSignals)
	assert.NoError(t, err)
	assert.False(t, verified, "proof with tampered public signals should not verify")
}

func TestVerifier_MalformedInput(t *testing.T) {
	t.Parallel()

	verifier, err := zkp.NewVerifier(vkPath())
	require.NoError(t, err)

	tests := []struct {
		name      string
		proof     string
		signals   string
		expectErr bool
	}{
		{"invalid proof JSON", "not-json", `["1","2","3"]`, true},
		{"invalid signals JSON", `{"pi_a":["1","2","1"],"pi_b":[["3","4"],["5","6"],["1","0"]],"pi_c":["7","8","1"],"protocol":"groth16","curve":"bn128"}`, "not-json", true},
	}

	for _, tc := range tests {
		t.Run(tc.name, func(t *testing.T) {
			t.Parallel()
			_, err := verifier.Verify(tc.proof, tc.signals)
			if tc.expectErr {
				assert.Error(t, err)
			}
		})
	}
}
